<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8">

<title>class MeterAggregation - Rails Application Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/darkfish.js"></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">ActiveRecord::Base
  
</div>

    <div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
  
  
    <li><a class="include" href="Metering.html">Metering</a>
  
  
  </ul>
</div>

    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-aggregate_and_store">::aggregate_and_store</a>
    
    <li ><a href="#method-c-aggregate_missing_data">::aggregate_missing_data</a>
    
    <li ><a href="#method-c-daily_full_usage_sums">::daily_full_usage_sums</a>
    
    <li ><a href="#method-c-daily_usage_hash">::daily_usage_hash</a>
    
    <li ><a href="#method-c-daily_usage_sums">::daily_usage_sums</a>
    
    <li ><a href="#method-c-dtp_usage">::dtp_usage</a>
    
    <li ><a href="#method-c-inclusive_usage">::inclusive_usage</a>
    
    <li ><a href="#method-c-meter_usage">::meter_usage</a>
    
    <li ><a href="#method-c-total_dtp_usage_sums">::total_dtp_usage_sums</a>
    
    <li ><a href="#method-c-total_meter_usage_sums">::total_meter_usage_sums</a>
    
    <li ><a href="#method-c-total_usage_sum">::total_usage_sum</a>
    
    <li ><a href="#method-c-usage_by_dtp">::usage_by_dtp</a>
    
    <li ><a href="#method-c-usage_by_meter">::usage_by_meter</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-MeterAggregation">
  <h1 id="class-MeterAggregation" class="class">
    class MeterAggregation
  </h1>

  <section class="description">
    
  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-aggregate_and_store" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">aggregate_and_store</span><span
            class="method-args">(date_ranges, daily_time_periods, meters)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Aggregating Daily Usage from meter_records Creates aggregations based on
the meters&#39; retail plans, within the date range specified</p>
          
          

          
          <div class="method-source-code" id="aggregate_and_store-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 268</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">aggregate_and_store</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>
    <span class="ruby-identifier">daily_time_periods</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">all_day</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-keyword">not</span> ( <span class="ruby-identifier">date_ranges</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">daily_time_periods</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">meters</span>.<span class="ruby-identifier">empty?</span> )

<span class="ruby-comment">#     This is a hash of Meters we&#39;ll be aggregating</span>
      <span class="ruby-identifier">whitelist</span> = <span class="ruby-constant">Meter</span>.<span class="ruby-identifier">whitelist</span> <span class="ruby-identifier">meters</span>

<span class="ruby-comment">#     Selecting the date range</span>
      <span class="ruby-identifier">date_ranges_where</span> = <span class="ruby-identifier">date_ranges</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">date_range</span><span class="ruby-operator">|</span>
        <span class="ruby-node">&quot;            ( date &gt;= &#39;#{date_range[:start_date]}&#39; AND date &lt;= &#39;#{date_range[:end_date]}&#39; )\n&quot;</span>}

<span class="ruby-comment">#     Convert the unit of measurement to k</span>
      <span class="ruby-identifier">uom_usage_cases</span> = <span class="ruby-identifier">nem12_uom</span>.<span class="ruby-identifier">map</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">uom</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;      WHEN ( LOWER(uom) = LOWER(&#39;#{uom}&#39;) ) THEN usage * #{nem12_uom_to_kwh_multiplier uom}&quot;</span> }

      <span class="ruby-identifier">aggregations</span> = []

<span class="ruby-comment">#     Run an aggregation, and store, for each daily time period</span>
      <span class="ruby-identifier">daily_time_periods</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dtp</span><span class="ruby-operator">|</span>

<span class="ruby-comment">#       Get the start and end times as a minute of the day</span>
        <span class="ruby-identifier">start_minute</span> = <span class="ruby-identifier">time_to_minute</span> <span class="ruby-identifier">dtp</span>[<span class="ruby-value">:start_time</span>]
        <span class="ruby-identifier">end_minute</span> = <span class="ruby-identifier">time_to_minute</span> <span class="ruby-identifier">dtp</span>[<span class="ruby-value">:end_time</span>]

        <span class="ruby-keyword">if</span> <span class="ruby-identifier">start_minute</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">end_minute</span>
<span class="ruby-comment">#         Sum the whole day</span>
          <span class="ruby-identifier">usage_aggregation</span> = <span class="ruby-string">&quot;          ( SELECT SUM(s) FROM UNNEST(usage) s ) AS usage\n&quot;</span>
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">start_minute</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">end_minute</span>
<span class="ruby-comment">#         Sum where the time period occurs within one day</span>
          <span class="ruby-identifier">usage_aggregation</span> = <span class="ruby-node">&quot;          ( SELECT SUM(s) FROM UNNEST(usage[#{start_minute}/interval+1 : #{end_minute}/interval]) s ) AS usage\n&quot;</span>
        <span class="ruby-keyword">else</span>
<span class="ruby-comment">#         Sum where the time period occurs overnight</span>
          <span class="ruby-identifier">usage_aggregation</span> = <span class="ruby-string">&quot;          ( (SELECT SUM(t) FROM UNNEST( usage ) t ) - &quot;</span> <span class="ruby-operator">+</span>                                <span class="ruby-node">&quot;            ( SELECT SUM(s) FROM UNNEST(usage[#{end_minute} / interval + 1 : #{start_minute}/interval]) s ) ) AS usage&quot;</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-identifier">aggregations</span>.<span class="ruby-identifier">push</span>(

            <span class="ruby-string">&quot;      (\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;      SELECT\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;          meter_id,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;          register,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;          date,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-node">&quot;          TIMESTAMP &#39;#{dtp[:start_time]}&#39; as start_time,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-node">&quot;          TIMESTAMP &#39;#{dtp[:end_time]}&#39; as end_time,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;          VARCHAR &#39;kwh&#39; as uom,\n&quot;</span> <span class="ruby-operator">+</span>                         <span class="ruby-identifier">usage_aggregation</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;        FROM\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;          meter_records\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;        WHERE\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-node">&quot;          meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;        AND\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;          (\n&quot;</span> <span class="ruby-operator">+</span>                           <span class="ruby-identifier">date_ranges_where</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;        OR\n&quot;</span>) <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;          )\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;      )\n&quot;</span>
        )

      <span class="ruby-keyword">end</span>

<span class="ruby-comment">#     Start building the SQL query</span>
      <span class="ruby-identifier">sql</span> = <span class="ruby-string">&quot;INSERT INTO meter_aggregations\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;  (\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    meter_id,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    register,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    date,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    start_time,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    end_time,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    unit_of_measurement,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    usage\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;  )\n&quot;</span> <span class="ruby-operator">+</span>  
            <span class="ruby-string">&quot;  SELECT\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    meter_id,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    register,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    date,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    start_time,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    end_time,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    uom,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    ( CASE\n&quot;</span> <span class="ruby-operator">+</span>                      <span class="ruby-identifier">uom_usage_cases</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;\n&quot;</span>) <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;\n     ELSE usage\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;\n    END\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    ) AS usage\n&quot;</span> <span class="ruby-operator">+</span>  
            <span class="ruby-string">&quot;  FROM\n&quot;</span> <span class="ruby-operator">+</span>  
            <span class="ruby-string">&quot;    (\n&quot;</span> <span class="ruby-operator">+</span>  
                  <span class="ruby-identifier">aggregations</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;\n    UNION\n&quot;</span>) <span class="ruby-operator">+</span>  
            <span class="ruby-string">&quot;      ORDER BY\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;        meter_id,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;        register,\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;        date\n&quot;</span> <span class="ruby-operator">+</span>              <span class="ruby-string">&quot;    ) R\n&quot;</span>

<span class="ruby-comment">#     logger.info sql</span>
      <span class="ruby-identifier">result</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">raw_connection</span>.<span class="ruby-identifier">exec</span> <span class="ruby-identifier">sql</span>
      <span class="ruby-comment">#log_pg_result result</span>

<span class="ruby-comment">#     Make up some data for any gaps</span>
      <span class="ruby-identifier">aggregate_missing_data</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>

<span class="ruby-comment">#     Call to MeterPredictor here</span>
      <span class="ruby-identifier">date_ranges</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dr</span><span class="ruby-operator">|</span>
        <span class="ruby-constant">Meter</span>.<span class="ruby-identifier">predictor</span>.<span class="ruby-identifier">calculate</span> <span class="ruby-identifier">dr</span>[<span class="ruby-value">:start_date</span>], <span class="ruby-identifier">dr</span>[<span class="ruby-value">:end_date</span>], <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>
      <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">else</span>
      <span class="ruby-comment">#logger.info &quot;\\\\\\\\ Didn&#39;t aggregate_and_store anything&quot;</span>
    <span class="ruby-keyword">end</span>


  <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-aggregate_missing_data" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">aggregate_missing_data</span><span
            class="method-args">(date_ranges, daily_time_periods, meters)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Find gaps in aggregated data and fill it with estimations TODO – get the
billing interval from each meters <a href="RetailPlan.html">RetailPlan</a>
and use that instead of setting a target date of 1 month ago</p>
          
          

          
          <div class="method-source-code" id="aggregate_missing_data-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 423</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">aggregate_missing_data</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>

    <span class="ruby-identifier">whitelist</span> = <span class="ruby-constant">Meter</span>.<span class="ruby-identifier">whitelist</span> <span class="ruby-identifier">meters</span>
    <span class="ruby-identifier">all_dates</span> = []
    <span class="ruby-identifier">records_dates</span> = []
    <span class="ruby-identifier">dtps</span> = []

    <span class="ruby-identifier">daily_time_periods</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dtp</span><span class="ruby-operator">|</span>

      <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">push</span> <span class="ruby-string">&quot;        (\n&quot;</span> <span class="ruby-operator">+</span>                  <span class="ruby-string">&quot;          SELECT\n&quot;</span> <span class="ruby-operator">+</span>                  <span class="ruby-node">&quot;              TIMESTAMP &#39;#{dtp[:start_time]}&#39; as start_time,\n&quot;</span> <span class="ruby-operator">+</span>                  <span class="ruby-node">&quot;              TIMESTAMP &#39;#{dtp[:end_time]}&#39; as end_time\n&quot;</span> <span class="ruby-operator">+</span>                  <span class="ruby-string">&quot;          FROM\n&quot;</span> <span class="ruby-operator">+</span>                  <span class="ruby-string">&quot;            meter_aggregations\n&quot;</span> <span class="ruby-operator">+</span>                  <span class="ruby-string">&quot;        )\n&quot;</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">date_ranges</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">date_range</span><span class="ruby-operator">|</span>
<span class="ruby-comment">#     Generate a comprehensive list of dates we need numbers for</span>
      <span class="ruby-identifier">all_dates</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;          SELECT date::date FROM generate_series(&#39;#{date_range[:start_date]}&#39;, &quot;</span> <span class="ruby-operator">+</span>                <span class="ruby-node">&quot;&#39;#{date_range[:end_date]}&#39;, &#39;1 day&#39;::INTERVAL) date\n&quot;</span>

<span class="ruby-comment">#     Selecting the date range for the records where clause</span>
      <span class="ruby-identifier">records_dates</span> = <span class="ruby-identifier">date_ranges</span>.<span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">date_range</span><span class="ruby-operator">|</span>
        <span class="ruby-node">&quot;              ( date &gt;= &#39;#{date_range[:start_date]}&#39; AND date &lt;= &#39;#{date_range[:end_date]}&#39; )\n&quot;</span>}

    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">sql</span> = <span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;INSERT INTO\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;  meter_aggregations\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;  (\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    meter_id,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    register,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    date,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    start_time,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    end_time,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    unit_of_measurement,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    source,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    usage\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;  )\n&quot;</span> <span class="ruby-operator">+</span>  


          <span class="ruby-string">&quot;SELECT\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    -- These are the values that will be inserted back into meter_aggregations\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    meter_id,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    register,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    date,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    start_time,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    end_time,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    &#39;kwh&#39; AS unit_of_measurement,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    &#39;a&#39; AS source,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    COALESCE\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      (\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      -- When there&#39;s a valid source date to get some data from\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      (\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      SELECT\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          (\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            CASE\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;              WHEN\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;                DMRT.start_minute = DMRT.end_minute\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;              THEN\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;                ( SELECT SUM(s) FROM UNNEST(usage) s )\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;              WHEN\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;                DMRT.start_minute &lt; DMRT.end_minute\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;              THEN\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;                ( SELECT SUM(s) FROM UNNEST(usage[DMRT.start_minute / interval+1 : DMRT.end_minute / interval]) s )\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;              ELSE\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;                (\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;                  ( SELECT SUM(t) FROM UNNEST( usage ) t )\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;                    -\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;                  ( SELECT SUM(s) FROM UNNEST(usage[DMRT.end_minute / interval + 1 : DMRT.start_minute/interval]) s )\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;                )\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            END\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          )\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        FROM\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          meter_records\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        WHERE\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          meter_id = DMRT.meter_id\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        AND\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          register = DMRT.register\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        AND\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          date = DMRT.source_date\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        LIMIT 1\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      ),\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      -- When there&#39;s NOT a valid source date to get some data from\n&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;      (\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        CASE\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          WHEN\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            DMRT.start_minute = DMRT.end_minute\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          THEN\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            160.0 * 1000.0 / 365.0  / 1440.0\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;              * \n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            1440.0\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          WHEN\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            DMRT.start_minute &lt; DMRT.end_minute\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          THEN\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            160.0 * 1000.0 / 365.0  / 1440.0\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;              *\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            ( DMRT.end_minute - DMRT.start_minute )\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          ELSE -- ( start &gt; end )\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            160.0 * 1000.0 / 365.0  / 1440.0\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;              *\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            1440.0 - DMRT.start_minute - DMRT.end_minute\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          END\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        )\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    ) AS usage\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;  FROM\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;(\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;SELECT\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    meter_id,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    register,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    date,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    source_date,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    start_time,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    end_time,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    ( EXTRACT(MINUTE FROM start_time) + EXTRACT(HOUR FROM start_time) * 60 ) AS start_minute,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    ( EXTRACT(MINUTE FROM end_time) + EXTRACT(HOUR FROM end_time) * 60 ) AS end_minute\n&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;  FROM\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    (\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      (\n&quot;</span> <span class="ruby-operator">+</span>                       <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;        UNION\n&quot;</span>) <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      )\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;  ) DTP\n&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;CROSS JOIN\n&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;(&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;SELECT\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    meter_id,\n&quot;</span>            <span class="ruby-string">&quot;    register,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    date,\n&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;    -- Coalesce target dates here\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    -- This is the date that we will aggregate, if one exists\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    COALESCE\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    (\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      (\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      SELECT\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          date\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        FROM\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          meter_records\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        WHERE\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          meter_id = CJ.meter_id\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        AND\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          register = CJ.register\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        AND\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          date = CJ.date - &#39;1 year&#39;::INTERVAL\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;       ),\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      (\n&quot;</span> <span class="ruby-operator">+</span>  
<span class="ruby-comment">#         TODO -- this needs to loop, trying every previous billing period</span>
<span class="ruby-comment">#                 to find a record, until 11 month prior to requested date.</span>

          <span class="ruby-string">&quot;      SELECT\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          date\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        FROM\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          meter_records\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        WHERE\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          meter_id = CJ.meter_id\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        AND\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          register = CJ.register\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        AND\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          date = CJ.date - &#39;1 month&#39;::INTERVAL\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;       ),\n&quot;</span> <span class="ruby-operator">+</span>  


          <span class="ruby-string">&quot;       NULL\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;     ) AS source_date\n&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;  FROM\n&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;-- Cross Join, CJ, to get all required combinations of\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;-- date, meter and register\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    (\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;-- Each date we expect a record for\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    SELECT\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        date,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        meter_id,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        register\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      FROM\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        (\n&quot;</span> <span class="ruby-operator">+</span>                       <span class="ruby-identifier">all_dates</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;        UNION\n&quot;</span>) <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        ) D\n&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;      CROSS JOIN\n&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;      (\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;-- Unique meters / registers\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      SELECT DISTINCT\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          meter_id, register\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        FROM\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          meter_records\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        WHERE\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-node">&quot;          meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      ) MR\n&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;    ) CJ\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;--  End Cross Join\n&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;-- But only pick those dates / meters / registers\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;-- that we don&#39;t have records for\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;  WHERE  NOT EXISTS\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    (\n&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;    SELECT\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        1\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      FROM\n&quot;</span> <span class="ruby-operator">+</span>  
          <span class="ruby-string">&quot;        (\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;--      Records that exist in these date ranges\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        SELECT\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            meter_id,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            register,\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            date\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          FROM\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            meter_records\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;          WHERE\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            (\n&quot;</span> <span class="ruby-operator">+</span>                           <span class="ruby-identifier">records_dates</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;            OR\n&quot;</span>) <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;            )\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        ) R\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      WHERE\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        CJ.date = R.date\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      AND\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        CJ.meter_id = R.meter_id\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;      AND\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;        CJ.register = R.register\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;    )\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;  ORDER BY date, meter_id, register\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;) DMR\n&quot;</span> <span class="ruby-operator">+</span>            <span class="ruby-string">&quot;) DMRT&quot;</span>

    <span class="ruby-comment">#logger.info sql</span>
    <span class="ruby-identifier">result</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">raw_connection</span>.<span class="ruby-identifier">exec</span> <span class="ruby-identifier">sql</span>

  <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-daily_full_usage_sums" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">daily_full_usage_sums</span><span
            class="method-args">(date_range, whitelist)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="daily_full_usage_sums-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 221</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">daily_full_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">whitelist</span>
  <span class="ruby-identifier">dtps</span> = [ { <span class="ruby-value">:start_time</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">all_day</span>[<span class="ruby-value">:start_time</span>], <span class="ruby-value">:end_time</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">all_day</span>[<span class="ruby-value">:end_time</span>] } ]
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">daily_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtps</span>, <span class="ruby-identifier">whitelist</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-daily_usage_hash" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">daily_usage_hash</span><span
            class="method-args">(result)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>TODO Move to private Returns a hash of usages per date</p>
          
          

          
          <div class="method-source-code" id="daily_usage_hash-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 258</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">daily_usage_hash</span> <span class="ruby-identifier">result</span>
  <span class="ruby-identifier">result</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> {<span class="ruby-value">:date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;date&quot;</span>].<span class="ruby-identifier">to_date</span>, <span class="ruby-value">:usage</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;usage&quot;</span>].<span class="ruby-identifier">to_f</span>} <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-daily_usage_sums" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">daily_usage_sums</span><span
            class="method-args">(date_range, daily_time_periods, whitelist)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets the daily usages for all meters in the whitelist and for the date
range specified. Returns an array of hashes in the form [ {:date=&gt; Date,
:usage =&gt; Float } ] TODO Move to private</p>
          
          

          
          <div class="method-source-code" id="daily_usage_sums-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 231</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">daily_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">whitelist</span>

  <span class="ruby-identifier">dtps</span> = []
  <span class="ruby-identifier">daily_time_periods</span>. <span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dtp</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;( start_time = &#39;#{dtp[:start_time]}&#39; AND end_time = &#39;#{dtp[:end_time]}&#39; )&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">sql</span> = <span class="ruby-node">&quot;SELECT
          date, SUM(usage) as usage
        FROM
          meter_aggregations
        WHERE
          meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])
        AND
          ( date &gt;= &#39;#{date_range[:start_date]}&#39; AND date &lt;= &#39;#{date_range[:end_date]}&#39; )
        AND
          #{dtps.join(&quot; OR &quot;)}
        GROUP BY date
        ORDER BY date;&quot;</span>

  <span class="ruby-identifier">result</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">raw_connection</span>.<span class="ruby-identifier">exec</span> <span class="ruby-identifier">sql</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">daily_usage_hash</span> <span class="ruby-identifier">result</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-dtp_usage" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dtp_usage</span><span
            class="method-args">(date_range, dtps, whitelist, options)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets an array of usage data hashes, broken down by Daily Time Period TODO
move to private</p>
          
          

          
          <div class="method-source-code" id="dtp_usage-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 109</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtp_usage</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtps</span>, <span class="ruby-identifier">whitelist</span>, <span class="ruby-identifier">options</span>
  <span class="ruby-identifier">usages</span> = <span class="ruby-identifier">total_dtp_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtps</span>, <span class="ruby-identifier">whitelist</span>

  <span class="ruby-identifier">suboptions</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">suboptions</span>[<span class="ruby-value">:nest</span>] = <span class="ruby-keyword">false</span>

  <span class="ruby-identifier">usages</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">usage</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">dtp</span> = [ { <span class="ruby-value">:start_time</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:start_time</span>], <span class="ruby-value">:end_time</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:start_time</span>] } ]

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:detailed</span>] <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:daily_usage</span>] = <span class="ruby-identifier">daily_full_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">whitelist</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:nest</span>] <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:meters</span>] = <span class="ruby-identifier">meter_usage</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtp</span>, <span class="ruby-identifier">whitelist</span>, <span class="ruby-identifier">suboptions</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">usages</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-inclusive_usage" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">inclusive_usage</span><span
            class="method-args">(date_ranges, daily_time_periods, meters, detailed)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets an array of top level, inclusive usage data hashes As per spec
Interface08, usage data in the top level of both returnable examples</p>
          
          

          
          <div class="method-source-code" id="inclusive_usage-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 63</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">inclusive_usage</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>, <span class="ruby-identifier">detailed</span>
  <span class="ruby-identifier">whitelist</span> = <span class="ruby-constant">Meter</span>.<span class="ruby-identifier">whitelist</span> <span class="ruby-identifier">meters</span>
  <span class="ruby-identifier">usages</span> = []
  <span class="ruby-identifier">date_ranges</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">date_range</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">usage</span> = {
      <span class="ruby-value">:retrieved</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>.<span class="ruby-identifier">to_s</span>,
      <span class="ruby-value">:start_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">date_range</span>[<span class="ruby-value">:start_date</span>],
      <span class="ruby-value">:end_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">date_range</span>[<span class="ruby-value">:end_date</span>],
      <span class="ruby-value">:usage</span> =<span class="ruby-operator">&gt;</span> ( <span class="ruby-identifier">total_usage_sum</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">whitelist</span> ),
    }
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">detailed</span> <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:daily_usage</span>] = ( <span class="ruby-identifier">daily_full_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">whitelist</span> )
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">usages</span>.<span class="ruby-identifier">push</span> <span class="ruby-identifier">usage</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">usages</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-meter_usage" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">meter_usage</span><span
            class="method-args">(date_range, dtps, whitelist, options)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets an array of usage data hashes, broken down by <a
href="Meter.html">Meter</a> TODO move to private</p>
          
          

          
          <div class="method-source-code" id="meter_usage-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 88</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">meter_usage</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtps</span>, <span class="ruby-identifier">whitelist</span>, <span class="ruby-identifier">options</span>
  <span class="ruby-identifier">usages</span> = <span class="ruby-identifier">total_meter_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">whitelist</span>

  <span class="ruby-identifier">suboptions</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">suboptions</span>[<span class="ruby-value">:nest</span>] = <span class="ruby-keyword">false</span>

  <span class="ruby-identifier">usages</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">usage</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">shortlist</span> = { <span class="ruby-identifier">whitelist</span>.<span class="ruby-identifier">key</span>(<span class="ruby-identifier">usage</span>[<span class="ruby-value">:serial</span>]) =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:serial</span>] }

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:detailed</span>] <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:daily_usage</span>] = <span class="ruby-identifier">daily_full_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">shortlist</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:nest</span>] <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:daily_time_periods</span>] = <span class="ruby-identifier">dtp_usage</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">dtps</span>, <span class="ruby-identifier">shortlist</span>, <span class="ruby-identifier">suboptions</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">usages</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-total_dtp_usage_sums" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">total_dtp_usage_sums</span><span
            class="method-args">(date_range, daily_time_periods, whitelist)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets the total usage each meter in the whitelist and for the date range
specified. Returns a float. TODO Move to private</p>
          
          

          
          <div class="method-source-code" id="total_dtp_usage_sums-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 160</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">total_dtp_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">whitelist</span>
  <span class="ruby-identifier">labels</span> = []
  <span class="ruby-identifier">dtps</span> = []
  <span class="ruby-identifier">daily_time_periods</span>. <span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dtp</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;( start_time = &#39;#{dtp[:start_time]}&#39; AND end_time = &#39;#{dtp[:end_time]}&#39; )&quot;</span>
    <span class="ruby-identifier">labels</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;WHEN ( start_time = &#39;#{dtp[:start_time]}&#39; AND end_time = &#39;#{dtp[:end_time]}&#39; ) THEN &#39;#{dtp[:label]}&#39;\n&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">sql</span> = <span class="ruby-node">&quot;SELECT
          start_time, end_time, SUM(usage) AS usage,
          ( CASE
              #{labels.join()}
                ELSE &#39;&#39;
              END
          ) AS label
        FROM
          meter_aggregations
        WHERE
          meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])
        AND
          ( date &gt;= &#39;#{date_range[:start_date]}&#39; AND date &lt;= &#39;#{date_range[:end_date]}&#39; )
        AND
          ( #{dtps.join(&quot; OR &quot;)} )
        GROUP BY start_time, end_time
        ORDER BY start_time, end_time;&quot;</span>

  <span class="ruby-comment">#logger.info sql</span>

  <span class="ruby-identifier">result</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">raw_connection</span>.<span class="ruby-identifier">exec</span> <span class="ruby-identifier">sql</span>
  <span class="ruby-identifier">usage</span> = <span class="ruby-identifier">result</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> { <span class="ruby-value">:start_time</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;start_time&quot;</span>], <span class="ruby-value">:end_time</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;end_time&quot;</span>], <span class="ruby-value">:label</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;label&quot;</span>], <span class="ruby-value">:usage</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;usage&quot;</span>].<span class="ruby-identifier">to_f</span> } <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">usage</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-total_meter_usage_sums" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">total_meter_usage_sums</span><span
            class="method-args">(date_range, whitelist)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets the total usage each meter in the whitelist and for the date range
specified. Returns a float. TODO Move to private</p>
          
          

          
          <div class="method-source-code" id="total_meter_usage_sums-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 133</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">total_meter_usage_sums</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">whitelist</span>
  <span class="ruby-identifier">dtps</span> = []
  <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;( start_time = &#39;#{all_day[:start_time]}&#39; AND end_time = &#39;#{all_day[:end_time]}&#39; )&quot;</span>

  <span class="ruby-identifier">sql</span> = <span class="ruby-node">&quot;SELECT
            serial, SUM(usage) AS usage
          FROM
            meter_aggregations AS MA INNER JOIN meters AS M ON M.id = MA.meter_id
          WHERE
              meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])
            AND
              ( date &gt;= &#39;#{date_range[:start_date]}&#39; AND date &lt;= &#39;#{date_range[:end_date]}&#39; )
            AND
              ( #{dtps.join(&quot; OR &quot;)} )
          GROUP BY serial
          ORDER BY serial;&quot;</span>

  <span class="ruby-identifier">result</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">raw_connection</span>.<span class="ruby-identifier">exec</span> <span class="ruby-identifier">sql</span>
  <span class="ruby-identifier">result</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span> {<span class="ruby-value">:serial</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;serial&quot;</span>], <span class="ruby-value">:usage</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;usage&quot;</span>].<span class="ruby-identifier">to_f</span>} <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-total_usage_sum" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">total_usage_sum</span><span
            class="method-args">(date_range, whitelist)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets the total usage for all meters in the whitelist and for the date range
specified. Returns a float. TODO Move to private</p>
          
          

          
          <div class="method-source-code" id="total_usage_sum-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 199</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">total_usage_sum</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">whitelist</span>
    <span class="ruby-identifier">dtps</span> = []
    <span class="ruby-identifier">dtps</span>.<span class="ruby-identifier">push</span> <span class="ruby-node">&quot;( start_time = &#39;#{all_day[:start_time]}&#39; AND end_time = &#39;#{all_day[:end_time]}&#39; )&quot;</span>

    <span class="ruby-identifier">sql</span> = <span class="ruby-node">&quot;SELECT
            SUM(usage) AS usage
          FROM
            meter_aggregations
          WHERE
            meter_id = ANY(&#39;{#{whitelist.keys.join(&quot;,&quot;)}}&#39;::int[])
          AND
            ( date &gt;= &#39;#{date_range[:start_date]}&#39; AND date &lt;= &#39;#{date_range[:end_date]}&#39; )
          AND
            ( #{dtps.join(&quot; OR &quot;)} );&quot;</span>
<span class="ruby-comment">#    logger.info sql</span>
<span class="ruby-comment">#    logger.info &quot;~~~~~~~~ End total_usage_sum ~~~~~~~~~&quot;</span>
    <span class="ruby-identifier">result</span> = <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>.<span class="ruby-identifier">connection</span>.<span class="ruby-identifier">raw_connection</span>.<span class="ruby-identifier">exec</span> <span class="ruby-identifier">sql</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">result</span>[<span class="ruby-value">0</span>][<span class="ruby-string">&quot;usage&quot;</span>].<span class="ruby-identifier">to_f</span>
  <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-usage_by_dtp" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">usage_by_dtp</span><span
            class="method-args">(date_ranges, daily_time_periods, meters, detailed = false)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets Usage data organized by Daily Time Period As per spec Interface08,
usage organized by daily time period</p>
          
          

          
          <div class="method-source-code" id="usage_by_dtp-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 40</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">usage_by_dtp</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>, <span class="ruby-identifier">detailed</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-identifier">whitelist</span> = <span class="ruby-constant">Meter</span>.<span class="ruby-identifier">whitelist</span> <span class="ruby-identifier">meters</span>
<span class="ruby-comment">#   Get an array of top level, inclusive usage data organised by date range</span>
    <span class="ruby-identifier">usages</span> = <span class="ruby-identifier">inclusive_usage</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>, <span class="ruby-identifier">detailed</span>

    <span class="ruby-identifier">options</span> = { <span class="ruby-value">:nest</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:detailed</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">detailed</span> }

    <span class="ruby-identifier">usages</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">usage</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:source</span>] = <span class="ruby-string">&quot;Usage by Daily Time Period&quot;</span>
      <span class="ruby-identifier">date_range</span> = {
        <span class="ruby-value">:start_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:start_date</span>],
        <span class="ruby-value">:end_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:end_date</span>]
      }
<span class="ruby-comment">#     Add an array of usage data hashes, broken down by Daily Time Period</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:daily_time_periods</span>] = <span class="ruby-identifier">dtp_usage</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">whitelist</span>, <span class="ruby-identifier">options</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">usages</span>
  <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-usage_by_meter" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">usage_by_meter</span><span
            class="method-args">(date_ranges, daily_time_periods, meters, detailed = false)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Gets Usage data organized by <a href="Meter.html">Meter</a> As per spec
Interface08, usage organized by meter</p>
          
          

          
          <div class="method-source-code" id="usage_by_meter-source">
            <pre><span class="ruby-comment"># File app/models/meter_aggregation.rb, line 18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">usage_by_meter</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>, <span class="ruby-identifier">detailed</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-identifier">whitelist</span> = <span class="ruby-constant">Meter</span>.<span class="ruby-identifier">whitelist</span> <span class="ruby-identifier">meters</span>
<span class="ruby-comment">#   Get an array of top level, inclusive usage data organised by date range</span>
    <span class="ruby-identifier">usages</span> = <span class="ruby-identifier">inclusive_usage</span> <span class="ruby-identifier">date_ranges</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">meters</span>, <span class="ruby-identifier">detailed</span>

    <span class="ruby-identifier">options</span> = { <span class="ruby-value">:nest</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>, <span class="ruby-value">:detailed</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">detailed</span> }

    <span class="ruby-identifier">usages</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">usage</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:source</span>] = <span class="ruby-string">&quot;Usage by Meter&quot;</span>
      <span class="ruby-identifier">date_range</span> = {
        <span class="ruby-value">:start_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:start_date</span>],
        <span class="ruby-value">:end_date</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">usage</span>[<span class="ruby-value">:end_date</span>]
      }
<span class="ruby-comment">#     Add an array of usage data hashes, broken down by Meter</span>
      <span class="ruby-identifier">usage</span>[<span class="ruby-value">:meters</span>] = <span class="ruby-identifier">meter_usage</span> <span class="ruby-identifier">date_range</span>, <span class="ruby-identifier">daily_time_periods</span>, <span class="ruby-identifier">whitelist</span>, <span class="ruby-identifier">options</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">usages</span>
  <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

